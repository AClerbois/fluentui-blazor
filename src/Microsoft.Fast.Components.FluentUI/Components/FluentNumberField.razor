@inherits FluentInputBase<TValue>
@typeparam TValue
@using System.Globalization;
@using System.Reflection;

<fluent-number-field autofocus="@Autofocus"
                     appearance="@Appearance.ToAttributeValue()"
                     value="@BindConverter.FormatValue(CurrentValueAsString)"
                     step="@Step"
                     min="@Min"
                     max="@Max"
                     maxlength="@MaxLength"
                     @onchange="@(EventCallback.Factory.CreateBinder<string>(this, __value => CurrentValueAsString = __value, CurrentValueAsString))"
                     readonly="@Readonly"
                     disabled="@Disabled"
                     required="@Required"
                     placeholder="@Placeholder"
                     @attributes="AdditionalAttributes">
    @ChildContent
</fluent-number-field>

@code{
    [Parameter] public bool? Disabled { get; set; }

    [Parameter] public bool? Readonly { get; set; }

    [Parameter] public bool? Required { get; set; }

    [Parameter] public bool? Autofocus { get; set; }

    [Parameter] public Resize? Resize { get; set; }

    [Parameter] public NumberFieldAppearance? Appearance { get; set; }

    [Parameter] public string Placeholder { get; set; }

    [Parameter] public string ParsingErrorMessage { get; set; } = "The {0} field must be a number.";

    [Parameter] public RenderFragment ChildContent { get; set; }

    [Parameter] public TValue Min { get; set; } = GetMinOrMaxValue("MinValue");
    [Parameter] public TValue Max { get; set; } = GetMinOrMaxValue("MaxValue");
    //[Parameter] public int MinLength { get; set; } = 10;
    [Parameter] public int MaxLength { get; set; } = 99;
    [Parameter] public int Step { get; set; } = _stepAttributeValue;

    private readonly static int _stepAttributeValue; 

    static FluentNumberField()
    {
        // Unwrap Nullable<T>, because InputBase already deals with the Nullable aspect
        // of it for us. We will only get asked to parse the T for nonempty inputs.
        var targetType = Nullable.GetUnderlyingType(typeof(TValue)) ?? typeof(TValue);

        if (targetType == typeof(int) ||
            targetType == typeof(long) ||
            targetType == typeof(short) ||
            targetType == typeof(float) ||
            targetType == typeof(double) ||
            targetType == typeof(decimal))
        {
            _stepAttributeValue = 1;
        }
        else
        {
            throw new InvalidOperationException($"The type '{targetType}' is not a supported numeric type.");
        }
    }



    protected override bool TryParseValueFromString(string value, out TValue result, out string validationErrorMessage)
    {
        if (BindConverter.TryConvertTo<TValue>(value, CultureInfo.InvariantCulture, out result))
        {
            validationErrorMessage = null;
            return true;
        }
        else
        {
            validationErrorMessage = string.Format(CultureInfo.InvariantCulture, ParsingErrorMessage, /*DisplayName ??*/ FieldIdentifier.FieldName);
            return false;
        }
    }

    /// <summary>
    /// Formats the value as a string. Derived classes can override this to determine the formatting used for <c>CurrentValueAsString</c>.
    /// </summary>
    /// <param name="value">The value to format.</param>
    /// <returns>A string representation of the value.</returns>
    protected override string? FormatValueAsString(TValue? value)
    {
        // Avoiding a cast to IFormattable to avoid boxing.
        switch (value)
        {
            case null:
                return null;

            case int @int:
                return BindConverter.FormatValue(@int, CultureInfo.InvariantCulture);

            case long @long:
                return BindConverter.FormatValue(@long, CultureInfo.InvariantCulture);

            case short @short:
                return BindConverter.FormatValue(@short, CultureInfo.InvariantCulture);

            case float @float:
                return BindConverter.FormatValue(@float, CultureInfo.InvariantCulture);

            case double @double:
                return BindConverter.FormatValue(@double, CultureInfo.InvariantCulture);

            case decimal @decimal:
                return BindConverter.FormatValue(@decimal, CultureInfo.InvariantCulture);

            default:
                throw new InvalidOperationException($"Unsupported type {value.GetType()}");
        }
    }

    private static TValue GetMinOrMaxValue(string name)
    {
        FieldInfo field = typeof(TValue).GetField(name,
            BindingFlags.Public | BindingFlags.Static);
        if (field == null)
        {
            // There's no TypeArgumentException, unfortunately. You might want
            // to create one :)
            throw new InvalidOperationException
                ("Invalid type argument for NumericUpDown<T>: " +
                 typeof(TValue).Name);
        }
        return (TValue)field.GetValue(null);
    }
}